# 语法树
以下是4.5.1混合搜索的语法范围

![画板](https://intranetproxy.alipay.com/skylark/lark/0/2025/jpeg/190256611/1764570780511-3135a388-8244-4ff4-a3fa-ec9c8ace5200.jpeg)

# 全文
| 类型 | 项 | 功能点 | 具体说明 | 示例（这里不一定体现boost，因为DSL语法有差异） |
| --- | --- | --- | --- | --- |
| 全文 | match | 多关键词 | 单个字段的多关键词匹配 | ```json "match": {"content": "some new algorithms"} ```  |
| | | boost | 指定权重 | |
| | query_string | 多字段及其权重 | fields支持多个字段，且每个字段支持指定权重 | ```json "query_string": {   "fields": ["title^0.3", "author^0.2"],   "query": "Gatsby Fitzgerald American^0.2 Dream^0.1",   "type": "best_fields",   "default_operator": "OR",   "minimum_should_match": "45%",   "boost": 0.6, } ```  |
| | | 多关键词 | query支持多关键词，形如'"query": "tkn_0 tkn_1 ... tkn_n"'，性能明显下降的token数量阈值，作为功能范围边界 | |
| | | 关键词权重 | + 指定每个关键词的权重<br/>+ 分词逻辑是，连续没有权重的词或有权重的词，视为一个词组，比如右边分词结果是"Gatsby Fitzgerald"、"American"、"Dream"3个词组<br/>+ 关键词带权重在450的性能不可用 | |
| | | type | best_fields、most_fields、cross_fields、phrase | |
| | | default_operator | OR、AND | |
| | | minimum_should_match | 多关键词最小匹配数量 | |
| | | boost | 指定权重 | |
| | multi_match | 多字段及其权重 | + multi_match不支持指定权重<br/>+ 多token是指形如'"query": "tkn_0 tkn_1 ... tkn_n"'，需要定界性能明显下降的token数量阈值，作为功能范围 | ```json "multi_match": {   "query": "Gatsby Fitzgerald American Dream",   "type": "best_fields",   "operator": "OR",   "minimum_should_match": "45%",   "boost": 0.6, } ```  multi_match类似一个简单版的query_string，区别是<br/>+ query不支持指定关键词权重，进而分词逻辑不同<br/>+ 字段operator，和query_string的default_operator不同名但等效 |
| | | 多关键词 | query支持多关键词，形如'"query": "tkn_0 tkn_1 ... tkn_n"'，性能明显下降的token数量阈值，作为功能范围边界 | |
| | | type | + best_fields、most_fields、cross_fields、phrase | |
| | | operator | OR、AND | |
| | | minimum_should_match | 多关键词最小匹配数量 | |
| | | boost | 指定权重 | |
| | match_phrase | 词组查询 | 按一个词组搜索<br/>+ <font style="color:rgb(25, 27, 31);">字段必须包含所有词项，并且顺序必须相同</font><br/>+ <font style="color:rgb(25, 27, 31);">词项之间不能有其他词项</font> | ```json "match_phrase": {"desc": "some new algorithms"} ```  |
| | | boost | 指定权重 | ```json "match_phrase": {   "desc": {     "query": "some new algorithms",     "boost": 2   } } ```  |
| 标量 | range | gte、gt、lte、lt | 范围条件 | ```json "range": {"price": {"gte": 10,"lte": 20}} ```  |
| | | boost | 指定权重 | |
| | term | 精准匹配 | 等值条件 | ```json "term": {"book_id" : 2} ```  |
| | | boost | 指定权重 | |
| | terms | 多值精准匹配 | 多值等值条件 | ```json "terms": {"category": ["fiction", "Mystery"]} ```  |
| | | boost | 指定权重 | |
| | rank_feature | saturation |  | ```json "rank_feature": {   "field" : "book_id",   "saturation": {"pivot": 2} } ```  |
| | | linear |  | ```json "rank_feature": {   "field" : "price",   "linear": {} } ```  |
| | | log |  | ```json "rank_feature" : {   "field" : "book_id",   "log": {"scaling_factor": 1.0} } ```  |
| | | sigmoid |  | ```json "rank_feature": {   "field" : "book_id",   "sigmoid": {     "pivot": 7,     "exponent": 2,     "scaling_factor": 2   } } ```  |
| | | 不用支持boost |  | |
| 组合 | bool | 对以上查询项的组合查询 | + 每项都是其他项的数组<br/>+ 支持嵌套bool，基于联通的场景，要支持bool嵌套一层bool | ```json {   "query": {     "bool": {       "must": [         {           "query_string": {             "query": "",              "fields": ["title_tks^10"]}         }],       "filter": [         {           "terms": {             "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}},          {           "bool": {             "must_not": [               {                 "range": {"available_int": {"lt": 1}}               }             ]           }         }       ]     }   } } ```  + 这是联通场景的DSL，简化了字段值，主要体现查询层次的复杂度，嵌套层次为<font style="color:#DF2A3F;">bool</font>(->filter)<font style="color:#DF2A3F;">->bool</font>(->must_not)<font style="color:#DF2A3F;">->range</font>，相当于3层嵌套<br/>+ 这个case，第3层的bool->must_not在filter里，也可以提升到第2层，等效 |
| | | must<br/><br/><br/> | 全都满足，算分 | |
| | | should | 至少满足minimum_should_match项，且算分 | |
| | | filter | 全都满足，不算分 | |
| | | must_not | 反向过滤，任一都不满足 | |
| | | minimum_should_match | should最小匹配数量 | |
| | | boost | 指定权重 | |
| json | json_contains | field | json字段 | ```json "json_contains": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } } ```  |
| | | candidate | 参数 | |
| | | path | 可选，json路径 | |
| | json_member_of | field | json字段 | ```json "json_member_of": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } } ```  |
| | | candidate | 参数 | |
| | | path | 可选，json路径 | |
| | json_overlaps | field | json字段 | ```json "json_overlaps": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } } ```  |
| | | candidate | 参数 | |
| | | path | 可选，json路径 | |


# 向量
| 类型 | 功能点 | 具体说明 | 示例（这里不一定体现boost，因为DSL语法有差异） |
| --- | --- | --- | --- |
| 向量 | field | 指定向量字段 | ```json   "knn": {     "field": "q_1024_vec",     "k": 1024,     "query_vector": [],     "similarity": 0.5,     "filter": {       "bool": {         "must": [           {             "query_string": {               "query": "",                "fields": ["title_tks^10"]             }           }         ],         "filter": [           {             "terms": {               "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}},            {             "bool": {               "must_not": [                 {                   "range": {"available_int": {"lt": 1}}                 }               ]             }           }         ],         "boost": 1.323525       }     }   } ```  |
| | k | 指定返回相关性最高的k行 | |
| | query_vector | 指定查询向量 | |
| | similarity | 指定相似度过滤条件 | |
| | boost | 指定权重 | |
| | filter | + 指定全文/标量过滤条件<br/>+ 语法和前面全文一样，只过滤不算分 | |
| | 多路向量 | + 多路向量搜索相加<br/>+ 每路都是单独的向量搜索，支持以上向量搜索各功能点<br/>+ 各路的field可以是不同字段 | ```json "knn": [     {       "field": "v1",       "k": 3,       "query_vector": [79.59,40.15,5.25],       "boost": 0.1480532255002669,       "similarity": 4,       "filter": [         {           "terms": {             "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}},          {           "bool": {             "must_not": [               {                 "range": {"available_int": {"lt": 1}}               }             ]           }         }       ]     },     {       "field": "v1",       "k": 6,       "query_vector": [90.38,63.66,71.3],       "similarity": 0} ] ```  |


# rank
| 排序方式 | 450支持情况 | 451期望支持 | 示例 |
| --- | --- | --- | --- |
| min_score |  | ✅<br/>最小分数过滤<br/>可独立于归一化、rrf使用 |  |
| 普通融合 | ✅ | ✅ |  |
| 归一化+加权 | | ✅目前支持minmax<br/>参考[混搜归一化方案设计](https://yuque.antfin.com/ob/gtuwei/emsncysh1qarvecq) | ```json {   "query": {     "query_string": {       "fields": ["title", "author", "description"],       "query": "fiction American Dream",       "boost": 1.2     }   },   "knn" : {     "field": "vector_embedding",     "k": 5,     "query_vector": [0.1, 0.2, 0.3, 0.4],     "boost": 2.6   },   "normalizer": "minmax"   "min_score": 0.6 } ```  |
| rrf | ✅ | ✅ | ```json {   "query": {     "query_string": {       "fields": ["title", "author", "description"],       "query": "fiction American Dream",       "boost": 1.2     }   },   "knn" : {     "field": "vector_embedding",     "k": 5,     "query_vector": [0.1, 0.2, 0.3, 0.4],     "boost": 2.6   },   "rank" : {     "rrf": {       "rank_window_size" : 10,       "rank_constant" : 60     }   } } ```  |
| wrrf | | ✅<br/>参考[WRRF方案](https://yuque.antfin.com/ob/gtuwei/se5s9ntuohv5b993) | |


# 其他
_source，指定查询字段

from，指定offset

size，指定limit

# 重点支持场景
以下是从客户需求和测试整理出的重点场景

[https://yuque.antfin.com/ob/gtuwei/gg81ysp8lqgcp0bu#owRU5](https://yuque.antfin.com/ob/gtuwei/gg81ysp8lqgcp0bu#owRU5)

| 场景来源 | 场景描述 | 示例 |
| --- | --- | --- |
| 联通 | 全文搜索<br/>+ 过滤<br/>    - 全文 - <br/>        * 多字段带权重<br/>        * 多关键词带权重<br/>        * minimum_should_match<br/>        * boost<br/>    - 多标量<br/>    - 标量反向过滤<br/>+ 算分<br/>    - 全文<br/>        * 多字段带权重<br/>        * 多关键词带权重<br/>        * minimum_should_match<br/>        * boost<br/><br/>向量搜索<br/>+ 过滤<br/>    - 和全文完全相同的过滤条件<br/> | ```json {   "query": {     "bool": {       "must": [         {           "query_string": {             "fields": ["title_tks^10", "title_sm_tks^5"],             "type": "best_fields",             "query": "",             "minimum_should_match": "0%",             "boost": 1           }         }       ],       "filter": [         {           "terms": {"kb_id": ["5bd17c4cbe0e11f0896ede928ce093d8"]}         },         {           "bool": {             "must_not": [               {                 "range": {"available_int": {"lt": 1}}               }             ]           }         }       ],       "boost": 0.050000000000000044     }   },   "knn": {     "field": "q_1024_vec",     "k": 1024,     "num_candidates": 2048,     "query_vector": [],     "filter": {       "bool": {         "must": [           {             "query_string": {               "fields": ["title_tks^10", "title_sm_tks^5"],               "type": "best_fields",               "query": "",               "minimum_should_match": "0%",               "boost": 1             }           }         ],         "filter": [           {             "terms": {"kb_id": ["5bd17c4cbe0e11f0896ede928ce093d8"]}           },           {             "bool": {               "must_not": [                 {                   "range": {"available_int": {"lt": 1}}                 }               ]             }           }         ],         "boost": 0.050000000000000044       }     },     "similarity": 0.2   },   "from": 0,   "size": 64 } ```  select<br/>  全文(多字段带权重, 多关键词带权重, minimum_should_match, boost)<br/>where<br/>  全文(多字段带权重, 多关键词带权重, minimum_should_match, boost)<br/>  AND 多个标量<br/>  AND NOT 多个标量or |
| 视源<br/>PowerRag | 全文搜索<br/>+ 过滤<br/>    - 全文<br/>        * 多字段带权重<br/>        * 多关键词带权重<br/>        * minimum_should_match<br/>    - 多标量<br/>    - 标量反向过滤<br/>+ 算分<br/>    - 全文<br/>        * 多字段带权重<br/>        * 多关键词带权重<br/>        * minimum_should_match<br/><br/>向量搜索<br/>+ 过滤<br/>    - 和全文完全相同的过滤条件 | ```json {   "query": {     "bool": {       "must": [         {           "query_string": {             "query": "",              "fields": ["title_tks^10"]           }         }       ],       "filter": [         {           "terms": {             "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}         },          {           "bool": {             "must_not": [               {                 "range": {"available_int": {"lt": 1}}               }             ]           }         }       ]     }   },   "knn": {     "field": "q_1024_vec",     "k": 1024,     "num_candidates": 2048,     "query_vector": [],     "similarity": 0.5,     "filter": {       "bool": {         "must": [           {             "query_string": {               "query": "",                "fields": ["title_tks^10"]             }           }         ],         "filter": [           {             "terms": {               "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}},            {             "bool": {               "must_not": [                 {                   "range": {"available_int": {"lt": 1}}                 }               ]             }           }         ],         "boost": 1.323525       }     }   },   "from": 0,   "size": 128 } ```  和联通的DSL类似，向量多了和全文一样的filter |
| 货拉拉 | 全文搜索<br/>+ 过滤+算分<br/>    - 全文<br/>        * 多字段<br/>        * 多关键词<br/>    - 多标量<br/><br/>向量搜索 - 不涉及 | ```json {   "query": {     "script_score": {       "query": {         "bool": {           "must": [             {               "terms": {                 "file_id" : [ "4335", "4517", "4518", "4519" ]               }             },             {               "multi_match": {                 "fields": [ "text", "text.keyword" ],                 "query": "测试",                 "type": "most_fields"               }             }           ]         }       }     }   } } ```  select<br/>  全文(多字段, 多关键词) + 多标量<br/>where<br/>  全文(多字段, 多关键词)<br/>  AND 多个标量 |
| 上汽 | 全文搜索<br/>+ 过滤<br/>    - 全文<br/>        * 单字段<br/>        * 多关键词<br/>    - 全文反向过滤<br/>        * 单字段<br/>        * 多关键词<br/>    - 多标量<br/>+ 算分<br/>    - 全文<br/>        * 单字段<br/>        * 多关键词<br/><br/>向量搜索 - 不涉及 | ```json {   "query": {     "bool": {       "must": [         {"match": {"content": "以旧换新超值"}}       ],       "must_not": [         {"match": {"content": "荣威"}}       ],       "filter": [         {"range": {"pub_time": {"gte": "2024-11-19 00:00:00"}}},         {"range": {"pub_time": {"lt": "2025-02-19 23:59:59"}}}       ]     }   } } ```  select<br/>  全文1(单字段, 多关键词)<br/>where<br/>  全文1(单字段, 多关键词)<br/>  AND NOT 全文2(单字段, 多关键词)<br/>  AND 多个标量 |
| 蚂蚁数科 | 全文搜索<br/>+ 过滤+算分<br/>    - 全文<br/>        * 单字段<br/>        * 多关键词<br/>    - 多标量<br/><br/>向量搜索 - 不涉及 | 和上汽的DSL类似，是它的简化场景 |
| 蚂蚁国际 | 全文搜索<br/>+ 过滤+算分<br/>    - 全文1<br/>        * 单字段<br/>        * 多关键词<br/>    - 全文2<br/>        * 单字段<br/>        * 多关键词<br/>    - ...<br/>    - 全文n<br/>        * 单字段<br/>        * 多关键词<br/>    - 多标量<br/><br/>向量搜索 - 不涉及 | ```json {   "query": {     "bool": {       "must": [         {"match": {"content": "以旧换新超值"}},         {"match": {"desc": "蚂蚁国际"}},         {"term": {"staff_id": 2}},         {"term": {"date": "2025-03-16"}}       ]     }   } } ```  select<br/>  全文1(单字段, 多关键词) + 全文1(单字段, 多关键词) + ... + 全文1(单字段, 多关键词) + 多个标量<br/>where<br/>  全文1(单字段, 多关键词)<br/>  AND 全文2(单字段, 多关键词)<br/>  ...<br/>  AND 全文n(单字段, 多关键词)<br/>  AND 多个标量 |
| 测试 | 全文搜索<br/>+ 过滤<br/>    - 全文<br/>        * 单字段<br/>        * 多关键词带权重<br/>    - 多标量<br/>+ 算分<br/>    - 全文<br/>        * 单字段<br/>        * 多关键词带权重<br/><br/>向量搜索<br/>+ 过滤<br/>    - minimum_should_match<br/>        * 全文<br/>            + 单字段<br/>            + 多关键词带权重<br/>            + minimum_should_match<br/>        * 多标量<br/>    - 多标量 | ```json {   "query": {     "bool": {       "should": [         {           "query_string": {             "fields": ["text"],             "query": "early^140 may why bad^83.025772"           }         }       ],       "filter": [         {"range": {"c1": {"gte": 2887}}}       ]     }   },   "knn": {     "field": "content_vector",     "k": 10,     "filter": [       {         "bool": {           "should": [             {"terms": {"knowledge_base_id": ["174", "176"]}},             {               "query_string": {                 "fields": ["text"],                 "query": "shall^91.498601 who with^31.652806",                 "boost": 0.061218,                 "minimum_should_match": "66%"               }             }           ]         }       },       {"range": {"id": {"lte": 136012}}},       {"range": {"c1": {"gte": 349411}}}     ],     "query_vector": []   },   "size": 10,   "_source": ["record_id"] } ```  这个场景的全文搜索和前面的场景类似，但是向量搜索有filter且和全文的不同<br/>select<br/>  向量()<br/>where<br/>  minimum_should_match(全文(单字段, 多关键词带权重, minimum_should_match), 多标量)<br/>  AND 多标量 |


# 功能点优先级及其边界
+ query_string/multi_match
    - 高优
        * 多字段，且带权重，已知最多7个字段
        * 多关键词，且带权重，已知最多约25个关键词
        * minimum_should_match
        * boost
        * type的best_fields、most_fields
    - 低优
        * type的cross_fields、phrase，没用到过
        * (default_)operator没用到过，默认OR
+ boost
    - 高优
        * 全文和向量最外层带boost，用于rerank
        * query_string/multi_match的boost，和其他算分项区分权重
        * 标量作为算分项，和其他算分项区分权重
    - 中优
        * query_string/multi_match/match作为算分项，里面的boost和其他算分项区分权重
        * 标量作为算分项，和其他算分项区分权重
        * 全文搜索和knn，只有rank_feature不支持boost，其他都支持boost
    - 说明
        * filter和must_not里的boost，不生效，因为只做过滤不算分
        * 对于rrf
            + 当不指定rrf时，query的最外层boost和knn最外层的boost代表rrf的每路权重
            + 当指定rrf时，全文内层的boost代表分数权重，和其他查询项形成权重区分，但全文和向量最外层的boost代表rerank后的权重，以下面的DSL为例

```json
set @p ='{
  "query": {
    "bool": {
      "must": [
        {"match": {"c18": {"query" : "a long story", "boost" : 2.3}}},
        {"query_string": {
          "fields": ["c18"],
          "query": "a long story",
          "type": "cross_fields",
          "boost": 2
        }}
      ],
      "boost": 1.5
    }
  },
  "knn": [
    {"field": "v1","k": 3,"query_vector": [79.59,40.15,5.25],"boost": 0.7,"similarity": 4,
     "filter": {"term": {"book_id": 2, "boost": 2}}},
    {"field": "v1","k": 6,"query_vector": [90.38,63.66,71.3],"similarity": 0}],
  "_source": ["id"],
  "rank": {
    "rrf" : {
      "rank_window_size" : 10,
      "rank_constant" : 60
    }
  }
}';
```

+ 多个标量正向/反向过滤，高优
+ 反向全文过滤，形如NOT match(col1) against('a b c ' in natural language mode) ，中优
+ bool嵌套，最复杂bool->[must/should/filter/must_not]->bool->[must/should/filter/must_not]-><font style="color:#DF2A3F;">非bool</font>

```json
{
  "query": {
    "bool": {
      "must": [
        {
          "query_string": {
            "query": "", 
            "fields": ["title_tks^10"]}
        }],
      "filter": [
        {
          "terms": {
            "kb_id": ["1ddfaf221f2011f0a99e1a9675c643d4"]}}, 
        {
          "bool": {
            "must_not": [
              {
                "range": {"available_int": {"lt": 1}}
              }
            ]
          }
        }
      ]
    }
  }
}
```

+ <font style="color:#000000;">rank_feature目前没找到使用场景</font>
+ 全文搜索通用场景，已知场景都可以拆解成这样
    - 全文+标量+标量反向+(全文反向，低频)，全文算分，标量有时也算分
+ 向量搜索通用场景，基本都带filter
    - 高优
        * 和全文的filter相同
    - 中优
        * 和全文的filter不同，形如minimum_should_match(全文(单字段, 多关键词, minimum_should_match), 多标量) AND 多标量
+ _source、from、size指定投影、offset和limit，高优

# 新增语法和遗留问题
## match_phrase语法
以下两种语法都支持，兼容ES语法，支持boost

```json
// 不带boost
"match_phrase": {"desc": "some new algorithms"}

// 带boost
"match_phrase": {
  "desc": {
    "query": "this is a test",
    "boost": 4.51
  }
}
```

## json表达式
| 类型 | 项 | 功能点 | 具体说明 | 示例 |
| --- | --- | --- | --- | --- |
| json | json_contains | field | json字段 | ```sql set @param = '{"json_contains": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } }}';  set @param = '{"json_contains": {   "doc_json": {     "candidate": {       "metadata": {"type": "production"}     },     "path": "$"   } }}';  select json_contains(doc_json, candidate, path); ```  |
| | | candidate | 参数，支持<br/>+ json<br/>+ json格式的字符串 | |
| | | path | 可选，json路径，默认"$"，代表根节点 | |
| | json_member_of | field | json字段 | ```sql set @param = '{"json_member_of": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } }}';  set @param = '{"json_member_of": {   "doc_json": {     "candidate": {       "metadata": {"type": "production"}     },     "path": "$"   } }}';  // 指定path select json_member_of(candidate, json_extract(doc_json, path));  // 不指定path select json_member_of(candidate, doc_json); ```  |
| | | candidate | 参数，支持<br/>+ json<br/>+ json格式的字符串<br/>+ 数组<br/>+ 数组格式的字符串 | |
| | | path | 可选，json路径，默认"$"，代表根节点 | |
| | json_overlaps | field | json字段 | ```sql set @param = '{"json_overlaps": {   "doc_json": {     "candidate": "{\\"metadata\\": {\\"type\\": \\"production\\"}}",     "path": "$"   } }}';  set @param = '{"json_overlaps": {   "doc_json": {     "candidate": {       "metadata": {"type": "production"}     },     "path": "$"   } }}';  // 指定path select json_overlaps(candidate, json_extract(doc_json, path));  // 不指定path SELECT json_overlaps(doc_json->path, candidate); ```  |
| | | candidate | 参数，支持<br/>+ json<br/>+ json格式的字符串<br/>+ 数组<br/>+ 数组格式的字符串 | |
| | | path | 可选，json路径，默认"$"，代表根节点 | |


+ path不是必选，用来指定json字段的子节点
+ 如果不指定path，在resolver阶段会默认构造"$"的raw expr，代表根节点

## rank_feature支持算分
上次讨论结论是标量只作过滤不算分，但rank_feature本身的意义就是通过标量算分提高重要程度，需要支持算分

[https://yuque.antfin.com/ob/gtuwei/sd7g10vtbafmmwoa#BRd5g](https://yuque.antfin.com/ob/gtuwei/sd7g10vtbafmmwoa#BRd5g)

## 全文和多路向量之间各自的filter相同
目前主要的通用场景如下

```json
set @p ='{
  "query": {
    "bool": {
      "must": [
        {"match": {"c18": {"query" : "a long story", "boost" : 2.3}}},
        {"query_string": {
          "fields": ["c18"],
          "query": "a long story",
          "type": "cross_fields",
          "boost": 2
        }}
      ],
      "boost": 1.5
    }
  },
  "knn": [
    {
      "field": "v1",
      "k": 3,
      "query_vector": [79.59,40.15,5.25],
      "boost": 0.7,
      "similarity": 4,
      "filter": [全文2]
    },
    {
      "field": "v1",
      "k": 6,
      "query_vector": [90.38,63.66,71.3],
      "similarity": 0,
      "filter": [全文3]
    }
    ],
  "_source": ["id"],
  "rank": {
    "rrf" : {
      "rank_window_size" : 10,
      "rank_constant" : 60
    }
  }
}';
```

之前从QA收集到有向量的filter和全文不相同的场景，经过进一步收集客户场景以及QA确认，目前实际场景里，上述例子的全文2和全文3，和query里的查询完全相同，可以只考虑【全文和多路向量之间各自的filter相同】的场景

## must/should/filter/must_not
|  场景 | 450行为 | ES | 示例 |
| --- | --- | --- | --- |
| bool里的must/should/filter/must_not的key存在，内容为空 | 报错，ES的行为没有梳理清楚，暂未放开 | 每一项为空，都有特殊行为，和没有这个key不完全相同 | ```sql set @p ='{   "query": {     "bool": {       "must": [],       "should": [],       "filter": [],       "must_not": []     }   } }'; ```  450的parser和451的resolver（开发中），会记录这个信息<br/><!-- 这是一张图片，ocr 内容为：OBDSLBOOLQUERY : PUBLIC OBDSLQUERY CLASS PUBLIC: OBDSLBOOLQUERY() 三 DELETE; C, OBDSLBOOLQUERY *GBOOL_QUERY, STATIC INT CREATE(OBIALLOCATOR &ALLOC, OBLE OBESQUERYITEM OUTER_QUERY_TYPE, OBDSLQUERY *PARENT_QUERY); VIRTUAL ~OBDSLBOOLQUERY() {} OBSEARRAY<OBDSLQUERY*, 4, MODULEPAGEALLOCATOR, TRUE> MUST_; OBSEARRAY<OBDSLQUERY*, 4, MODULEPAGEALLOCATOR, TRUE> SHOULD_; OBSEARRAY<OBDSLQUERY*, 4, MODULEPAGEALLOCATOR, TRUE> 1 FILTER_ OBSEARRAY<OBDSLQUERY*, 4, MODULEPAGEALLOCATOR, TRUE> MUST-NOT- /L FOR MUST/SHOULD/FILTER/MUST NOT, -1: NOT EXISTS, 0: EXJ : EXISTS BUT EMPTY, >0: EXISTS AND HAS CONTENT INT64_T MUST_CNT_; INT64_T SHOULD_CNT_; INT64_T FILTER_CNT_ON INT64_T MUST_NOT_CNT_ OBCONSTRAWEXPR *MSM_EXPR_; -->
![](https://intranetproxy.alipay.com/skylark/lark/0/2025/png/190256611/1765436218213-907d800e-39ec-4384-9863-82741f5f3015.png) |


## minimum_should_match
450旧框架基于拼sql的方式，按我们自己对ES的理解和一些性能考虑，做了一些关于minimum_should_match的特殊行为处理或限制

### 对各种输入的行为
**451先考虑支持整数**

450的支持情况和行为如下

| 各种情况 | 450行为 |
| --- | --- |
| 整数 | 支持 |
| 浮点数或带浮点数的百分比 | 报错 |
| 百分比，形如"60%" | + 对于multi_match/query_string，分词数*60%，向下取整<br/>+ 对于bool里的should，should count*60%，向下取整 |
| 负数，或者以上情况处理后为负数 | + 对于multi_match/query_string，取max(0, 分词数+负数)<br/>+ 对于should里的should，取max(0, should_count+负数) |
| 0，或者以上情况处理后为0 | 视为1 |


### 特殊场景
<!-- 这是一张图片，ocr 内容为：IF THE BOOL QUERY INCLUDES AT LEAST ONE SHOUID CLAUSE AND NO MUST O MUST OR FITTER CLAUSES,THE DEFAULT VALUE I. OTHERWISE,THEDEFAULT VALUE IS 0. -->
![](https://intranetproxy.alipay.com/skylark/lark/0/2025/png/190256611/1766472508125-5c837e1e-6739-4e95-b574-966d5e5c2c1a.png)

|  场景 | 450行为 | ES | 示例 |
| --- | --- | --- | --- |
| bool里同时满足以下3个条件<br/>+ 有should<br/>+ 但没有显式指定minimum_should_match<br/>+ 有must或filter（非should的正向过滤条件） | minimum_should_match默认为1，强制必须用should过滤，否则有性能问题， | minimum_should_match默认为0，也就是可以不满足should的任何一项，但是满足了也算分，有点“奖励性质地”算分 | ```sql set @p ='{   "query": {     "bool": {       "must": [         {"match": {           "desc": "a good story"}}       ],       "should": [         {"match": {           "title": "oceanbase hybrid search"}},         {"match": {           "author": "many geeks"}},         {"match": {           "desc": "a great database"}}],       "filter": [{         "match": {"desc": "a good story"}}]     }   } }';  # 450行为 select should的分数(含match表达式) + 其他分数 from tbl where should的过滤 and 其他过滤条件;  # ES行为对应的逻辑，should不做过滤，但算分 select should的分数(含match表达式) + 其他分数 from tbl where 其他过滤条件; ```  |


在450按拼sql的方式，如果和ES行为一致，主要有以下影响

+ 影响性能，这个场景下should只算分不过滤
+ 数据量极小的情况下，会有0分的结果

# 最小功能范围-联调范围
目前对于语法resolver和逻辑计划层面，考虑支持联调的最小功能范围如下

| 类型 | 项 | 功能点 | 参数 | 示例（包含所有最小功能范围的功能点） |
| --- | --- | --- | --- | --- |
| 全文 | 全文 | match | + field<br/>+ query<br/>+ boost | ```sql set @p ='{   "query": {     "bool": {       "must": [         "query_string": {           "fields": ["title^0.3", "author^0.2"],           "query": "American^0.2 Dream^0.1",           "type": "best_fields",           "minimum_should_match": "1",           "boost": 0.6,         }       ],       "should": [         {"match": {           "title": "oceanbase hybrid search"}},         {"multi_match": {           "fields": ["title^0.3", "author^0.2"],           "query": "American^0.2 Dream^0.1",           "type": "best_fields",           "minimum_should_match": "1",           "boost": 0.6,         }}       ],       "filter": [         {"range": {"price": {"gte": 1,"lte": 9}}}       ],       "must_not": [         {"term": {"age": 5}}       ],       "minimum_should_match": 1,       "boost": 3     }   },   "knn": [     {       "field": "v1",       "k": 3,       "query_vector": [79.59,40.15,5.25],              "filter": [全文]     },     {       "field": "v1",       "k": 6,       "query_vector": [90.38,63.66,71.3],       "boost": 0.7,       "filter": [全文]     }   ],   "size": 10,   "from": 10 }'; ```  |
| | | | | |
| | | match_phrase | + field<br/>+ query<br/>+ boost | |
| | | multi_match<br/>query_string | fields，多字段带权重 | |
| | | | query，多关键词带权重 | |
| | | | type，支持best_fields/most_fields/cross_fields | |
| | | | minimum_should_match | |
| | | | (default_)operator，支持OR和AND，AND预期性能有差距 | |
| | | | boost | |
| | 标量 | term | + field<br/>+ value | |
| | | range | + field<br/>+ operator<br/>+ value | |
| | | terms | + field<br/>+ value | |
| | 组合 | bool | must | |
| | | | should | |
| | | | filter | |
| | | | must_not | |
| | | | minimum_should_match | |
| | | | boost | |
| 向量 | knn |  | field | |
| | |  | k | |
| | |  | query_vector | |
| | |  | boost | |
| | |  | filter | |
| | 多路knn | 上述多个knn独立 | | |
| ~~rerank~~ | ~~~~ | | | |
| ~~size~~ |  | | | |
| ~~from~~ |  | | | |


被裁剪的功能点有

+ 全文搜索
    - 全文
        * 不支持query_string
        * multi_match的type，不支持phrase
    - 标量
        * rank_feature
+ 向量搜索
    - 无
+ rerank
    - ~~默认行为，最简单的分数相加，不支持归一化、wrrf等~~
    - 待确认，雨川
+ _scoure
    - 相较于dbms_hybrid_search的语法有差异，因为可以直接在select里填写，所以不再支持，hybrid_search表达式本身之前没有透出过



