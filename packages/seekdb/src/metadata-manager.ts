/**
 * Metadata Manager - Manages the sdk_collections metadata table
 * This table stores collection metadata for v2 collections
 */

import type { IInternalClient } from "./types.js";
import type { EmbeddingConfig, CreateCollectionOptions } from "./types.js";

export type CollectionVersion = "v2";
export interface CollectionMetadata {
  collectionId: string;
  collectionName: string;
  settings: {
    configuration?: CreateCollectionOptions["configuration"];
    version?: CollectionVersion;
    embeddingFunction?: {
      name: string;
      properties: EmbeddingConfig;
    };
    [key: string]: any;
  };
  createdAt?: Date;
  updatedAt?: Date;
}

export const METADATA_TABLE_NAME = "sdk_collections";

/**
 * Get column value from row case-insensitively (embedded/MySQL may return COLLECTION_ID etc.)
 */
function getColumn(row: Record<string, unknown>, columnName: string): unknown {
  const key = Object.keys(row).find(
    (k) => k.toLowerCase() === columnName.toLowerCase(),
  );
  return key !== undefined ? row[key] : (row as any)[columnName];
}

/**
 * Ensure metadata table exists, create if not
 */
export async function ensureMetadataTable(
  client: IInternalClient,
): Promise<void> {
  const createTableSql = `
    CREATE TABLE IF NOT EXISTS ${METADATA_TABLE_NAME} (
      collection_id CHAR(32) PRIMARY KEY DEFAULT (replace(uuid(), '-', '')),
      collection_name STRING,
      settings JSON COMMENT "Generated by SDK, don't modify",
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
      UNIQUE INDEX idx_name(collection_name)
    ) COMMENT='Settings of collections created by SDK'
  `;

  try {
    await client.execute(createTableSql);
  } catch (error) {
    throw new Error(
      `Failed to create metadata table: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

/**
 * Insert collection metadata and return the generated collection_id
 */
export async function insertCollectionMetadata(
  client: IInternalClient,
  collectionName: string,
  settings: CollectionMetadata["settings"]
): Promise<string> {
  // Ensure metadata table exists
  await ensureMetadataTable(client);

  // Insert metadata record
  const insertSql = `
    INSERT INTO ${METADATA_TABLE_NAME} (collection_name, settings)
    VALUES (?, ?)
  `;

  try {
    const settingsJson = JSON.stringify({ ...settings, version: "v2" });
    await client.execute(insertSql, [collectionName, settingsJson]);

    // Query the collection_id of the just-inserted record (retry for read-after-write visibility in embedded)
    const selectSql = `
      SELECT collection_id
      FROM ${METADATA_TABLE_NAME}
      WHERE collection_name = ?
      ORDER BY created_at DESC
      LIMIT 1
    `;
    const maxRetries = 3;
    const retryDelayMs = 20;
    let result: Record<string, unknown>[] | null = null;
    for (let i = 0; i < maxRetries; i++) {
      result = await client.execute(selectSql, [collectionName]) as Record<string, unknown>[] | null;
      if (result && result.length > 0) break;
      if (i < maxRetries - 1) {
        await new Promise((r) => setTimeout(r, retryDelayMs));
      }
    }

    // Fallback: SELECT last row by created_at (handles param binding or visibility issues)
    if (!result || result.length === 0) {
      const fallbackSql = `
        SELECT collection_id, collection_name
        FROM ${METADATA_TABLE_NAME}
        ORDER BY created_at DESC
        LIMIT 1
      `;
      const fallback = await client.execute(fallbackSql) as Record<string, unknown>[] | null;
      if (fallback && fallback.length > 0) {
        const row = fallback[0];
        const name = getColumn(row, "collection_name");
        if (String(name) === collectionName) {
          const id = getColumn(row, "collection_id");
          if (id != null && typeof id === "string") return id;
        }
      }
      throw new Error(
        "Failed to retrieve collection_id after inserting metadata"
      );
    }

    const collectionId = getColumn(result[0], "collection_id");
    if (collectionId == null || typeof collectionId !== "string") {
      throw new Error(
        "Failed to retrieve collection_id after inserting metadata",
      );
    }
    return collectionId;
  } catch (error) {
    if (error instanceof TypeError)
      throw new Error(
        `Failed to stringify Embedding Function config. Please ensure the getConfig() method returns a JSON-serializable object: ${error.message}`
      );
    else
      throw new Error(
        `Failed to insert collection metadata: ${error instanceof Error ? error.message : String(error)}`
      );
  }
}

/**
 * Get collection metadata by collection name
 */
export async function getCollectionMetadata(
  client: IInternalClient,
  collectionName: string,
): Promise<CollectionMetadata | null> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    WHERE collection_name = ?
  `;

  try {
    const result = await client.execute(selectSql, [collectionName]);

    if (!result || result.length === 0) {
      return null;
    }

    const row = result[0];
    const settings =
      typeof row.settings === "string"
        ? JSON.parse(row.settings)
        : row.settings;

    return {
      collectionId: row.collection_id as string,
      collectionName: row.collection_name as string,
      settings,
      createdAt: row.created_at
        ? new Date(row.created_at as string)
        : undefined,
      updatedAt: row.updated_at
        ? new Date(row.updated_at as string)
        : undefined,
    };
  } catch (error) {
    // If table doesn't exist, return null (fallback to v1)
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return null;
    }
    throw error;
  }
}

/**
 * Get collection metadata by collection_id
 */
export async function getCollectionMetadataById(
  client: IInternalClient,
  collectionId: string,
): Promise<CollectionMetadata | null> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    WHERE collection_id = ?
  `;

  try {
    const result = await client.execute(selectSql, [collectionId]);

    if (!result || result.length === 0) {
      return null;
    }

    const row = result[0];
    const settings =
      typeof row.settings === "string"
        ? JSON.parse(row.settings)
        : row.settings;

    return {
      collectionId: row.collection_id as string,
      collectionName: row.collection_name as string,
      settings,
      createdAt: row.created_at
        ? new Date(row.created_at as string)
        : undefined,
      updatedAt: row.updated_at
        ? new Date(row.updated_at as string)
        : undefined,
    };
  } catch (error) {
    // If table doesn't exist, return null
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return null;
    }
    throw error;
  }
}

/**
 * Delete collection metadata
 */
export async function deleteCollectionMetadata(
  client: IInternalClient,
  collectionName: string,
): Promise<void> {
  const deleteSql = `
    DELETE FROM ${METADATA_TABLE_NAME}
    WHERE collection_name = ?
  `;

  try {
    await client.execute(deleteSql, [collectionName]);
  } catch (error) {
    // If table doesn't exist, silently ignore (v1 collection)
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return;
    }
    throw error;
  }
}

/**
 * List all collection metadata
 */
export async function listCollectionMetadata(
  client: IInternalClient,
): Promise<CollectionMetadata[]> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    ORDER BY created_at DESC
  `;

  try {
    const result = await client.execute(selectSql);

    if (!result || result.length === 0) {
      return [];
    }

    return result.map((row) => {
      const settings =
        typeof row.settings === "string"
          ? JSON.parse(row.settings)
          : row.settings;

      return {
        collectionId: row.collection_id as string,
        collectionName: row.collection_name as string,
        settings,
        createdAt: row.created_at
          ? new Date(row.created_at as string)
          : undefined,
        updatedAt: row.updated_at
          ? new Date(row.updated_at as string)
          : undefined,
      };
    });
  } catch (error) {
    // If table doesn't exist, return empty array
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return [];
    }
    throw error;
  }
}

/**
 * Check if metadata table exists
 */
export async function metadataTableExists(
  client: IInternalClient,
): Promise<boolean> {
  const sql = `SHOW TABLES LIKE '${METADATA_TABLE_NAME}'`;

  try {
    const result = await client.execute(sql);
    return result !== null && result.length > 0;
  } catch (error) {
    return false;
  }
}
