/**
 * Metadata Manager - Manages the sdk_collections metadata table
 * This table stores collection metadata for v2 collections
 */

import type { InternalClient } from "./internal-client.js";

import type { EmbeddingConfig, CreateCollectionOptions } from "./types.js";

export type CollectionVersion = "v2";
export interface CollectionMetadata {
  collectionId: string;
  collectionName: string;
  settings: {
    configuration?: CreateCollectionOptions['configuration'];
    version?: CollectionVersion;
    embeddingFunction?: {
      name: string;
      properties: EmbeddingConfig;
    };
    [key: string]: any;
  };
  createdAt?: Date;
  updatedAt?: Date;
}

export const METADATA_TABLE_NAME = "sdk_collections";

/**
 * Ensure metadata table exists, create if not
 */
export async function ensureMetadataTable(
  client: InternalClient,
): Promise<void> {
  const createTableSql = `
    CREATE TABLE IF NOT EXISTS ${METADATA_TABLE_NAME} (
      collection_id CHAR(32) PRIMARY KEY DEFAULT (replace(uuid(), '-', '')),
      collection_name STRING,
      settings JSON COMMENT "Generated by SDK, don't modify",
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
      UNIQUE INDEX idx_name(collection_name)
    ) COMMENT='Settings of collections created by SDK'
  `;

  try {
    await client.execute(createTableSql);
  } catch (error) {
    throw new Error(
      `Failed to create metadata table: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Insert collection metadata and return the generated collection_id
 */
export async function insertCollectionMetadata(
  client: InternalClient,
  collectionName: string,
  settings: CollectionMetadata["settings"],
): Promise<string> {
  // Ensure metadata table exists
  await ensureMetadataTable(client);

  // Insert metadata record
  const insertSql = `
    INSERT INTO ${METADATA_TABLE_NAME} (collection_name, settings)
    VALUES (?, ?)
  `;

  try {
    const settingsJson = JSON.stringify({ ...settings, version: "v2" });
    await client.execute(insertSql, [collectionName, settingsJson]);

    // Query the collection_id of the just-inserted record
    const selectSql = `
      SELECT collection_id
      FROM ${METADATA_TABLE_NAME}
      WHERE collection_name = ?
      ORDER BY created_at DESC
      LIMIT 1
    `;

    const result = await client.execute(selectSql, [collectionName]);

    if (!result || result.length === 0) {
      throw new Error(
        "Failed to retrieve collection_id after inserting metadata",
      );
    }

    const collectionId = result[0].collection_id as string;
    return collectionId;
  } catch (error) {
    if (error instanceof TypeError)
      throw new Error(`Failed to stringify Embedding Function config. Please ensure the getConfig() method returns a JSON-serializable object: ${error.message}`);
    else throw new Error(
      `Failed to insert collection metadata: ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Get collection metadata by collection name
 */
export async function getCollectionMetadata(
  client: InternalClient,
  collectionName: string,
): Promise<CollectionMetadata | null> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    WHERE collection_name = ?
  `;

  try {
    const result = await client.execute(selectSql, [collectionName]);

    if (!result || result.length === 0) {
      return null;
    }

    const row = result[0];
    const settings =
      typeof row.settings === "string"
        ? JSON.parse(row.settings)
        : row.settings;

    return {
      collectionId: row.collection_id as string,
      collectionName: row.collection_name as string,
      settings,
      createdAt: row.created_at ? new Date(row.created_at as string) : undefined,
      updatedAt: row.updated_at ? new Date(row.updated_at as string) : undefined,
    };
  } catch (error) {
    // If table doesn't exist, return null (fallback to v1)
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return null;
    }
    throw error;
  }
}

/**
 * Get collection metadata by collection_id
 */
export async function getCollectionMetadataById(
  client: InternalClient,
  collectionId: string,
): Promise<CollectionMetadata | null> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    WHERE collection_id = ?
  `;

  try {
    const result = await client.execute(selectSql, [collectionId]);

    if (!result || result.length === 0) {
      return null;
    }

    const row = result[0];
    const settings =
      typeof row.settings === "string"
        ? JSON.parse(row.settings)
        : row.settings;

    return {
      collectionId: row.collection_id as string,
      collectionName: row.collection_name as string,
      settings,
      createdAt: row.created_at ? new Date(row.created_at as string) : undefined,
      updatedAt: row.updated_at ? new Date(row.updated_at as string) : undefined,
    };
  } catch (error) {
    // If table doesn't exist, return null
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return null;
    }
    throw error;
  }
}

/**
 * Delete collection metadata
 */
export async function deleteCollectionMetadata(
  client: InternalClient,
  collectionName: string,
): Promise<void> {
  const deleteSql = `
    DELETE FROM ${METADATA_TABLE_NAME}
    WHERE collection_name = ?
  `;

  try {
    await client.execute(deleteSql, [collectionName]);
  } catch (error) {
    // If table doesn't exist, silently ignore (v1 collection)
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return;
    }
    throw error;
  }
}

/**
 * List all collection metadata
 */
export async function listCollectionMetadata(
  client: InternalClient,
): Promise<CollectionMetadata[]> {
  const selectSql = `
    SELECT collection_id, collection_name, settings, created_at, updated_at
    FROM ${METADATA_TABLE_NAME}
    ORDER BY created_at DESC
  `;

  try {
    const result = await client.execute(selectSql);

    if (!result || result.length === 0) {
      return [];
    }

    return result.map((row) => {
      const settings =
        typeof row.settings === "string"
          ? JSON.parse(row.settings)
          : row.settings;

      return {
        collectionId: row.collection_id as string,
        collectionName: row.collection_name as string,
        settings,
        createdAt: row.created_at ? new Date(row.created_at as string) : undefined,
        updatedAt: row.updated_at ? new Date(row.updated_at as string) : undefined,
      };
    });
  } catch (error) {
    // If table doesn't exist, return empty array
    if (
      error instanceof Error &&
      (error.message.includes("doesn't exist") ||
        error.message.includes("Table") ||
        error.message.includes("not found"))
    ) {
      return [];
    }
    throw error;
  }
}

/**
 * Check if metadata table exists
 */
export async function metadataTableExists(
  client: InternalClient,
): Promise<boolean> {
  const sql = `SHOW TABLES LIKE '${METADATA_TABLE_NAME}'`;

  try {
    const result = await client.execute(sql);
    return result !== null && result.length > 0;
  } catch (error) {
    return false;
  }
}
